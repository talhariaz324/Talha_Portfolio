{"status":"ok","feed":{"url":"https://medium.com/feed/@talhariaz324","title":"Stories by Talha Riaz on Medium","link":"https://medium.com/@talhariaz324?source=rss-4e14ced2bc7e------2","author":"","description":"Stories by Talha Riaz on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*lF1wCNFrG1DcQr1q4EEo7g.png"},"items":[{"title":"\u201cDatabase Designs Volume 0.1\u201d","pubDate":"2022-09-02 14:44:21","link":"https://medium.com/@talhariaz324/database-designs-volume-0-1-ec49906a282c?source=rss-4e14ced2bc7e------2","guid":"https://medium.com/p/ec49906a282c","author":"Talha Riaz","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*A2hIVUWlsVrjIQoaTG6Aig.jpeg\"></figure><p>Intro:</p>\n<p>We are going to do database design of relational databases where data is stored in tables. We are going to store data in such a way that we can handle it easily for reading, deleting, updating, and\u00a0putting.</p>\n<p>Why?</p>\n<p>In database design, we simply design the schemas which ensure that our database is efficient.</p>\n<p>What do you mean by database efficiency?</p>\n<p>Database Efficiency is about data integrity(Correctness of\u00a0data).</p>\n<p><strong>For Example:</strong> If 2 tables are connected (How connects we will discuss later), because of some reason connection gets lost between two tables then the change in one table will not be shown in the other table. That is what is called data incorrectness. We should prevent\u00a0it.</p>\n<p>Schemas:</p>\n<p>Schemas are just a thing of the schematic to build something that tells you the way in which data will be structured. In the database we have 3 levels of database\u00a0design:</p>\n<ol>\n<li>Conceptual Schema (Most\u00a0General)</li>\n<li>Logica Schema\u00a0(Inter)</li>\n<li>Physical Schema (Specific)</li>\n</ol>\n<p><strong>NOTE:</strong> Above types vary from person to person. This means people divide it according to their understanding but we are going with these types. Whenever you find something other than don't confuse\u00a0it.</p>\n<h3><strong>Conceptual Schema:</strong></h3>\n<p>At this, we decide the relationships between the tables. A relational database is all about the\u00a0tables.</p>\n<h3>Logical Schema:</h3>\n<p>is something where you decide the table's relationship types as they can be: one to many, many to one, or many to many (we will discuss relationships soon).</p>\n<h3>Physical Schema:</h3>\n<p>is something where you decide such type of things as which type of server you are going to use, How people will access data? Is it using the web form? we have to program it accordingly. And then when you physically implement that is a time to program the database, build the webform, install the server, test, view, data to be returned and the most important thing is <strong>security</strong>. From here we start thinking about security so that nobody can break down the database.</p>\n<h3><strong>Database Design:</strong></h3>\n<p>Database Design is all about dividing data among tables rather than having only one table. For example, we are building a database for the users and managing their sales. So in the database, we should make 2 tables, the first is for users and the second is for sale instead of having in one\u00a0table.</p>\n<p>Database Design ensures data integrity.</p>\n<h3>Data Integrity:</h3>\n<p>The correctness of data is called data integrity. The database doesn\u2019t want incorrect data, duplication, and broken relations between the\u00a0tables.</p>\n<p><strong>Three types of data integrity:</strong></p>\n<ol>\n<li>\n<strong>Entity Integrity: </strong>All about that only one table with one name. having some unique key which distinguishes between like users table having\u00a0id.</li>\n<li>\n<strong>Referential integrity:</strong> The relation between the tables. This relation is done by the foreign key. The foreign key constraint is understanding with an example that we have two 2 tables. \u201c<strong>Users\u201d</strong> and \u201c<strong>Comments\u201d</strong> So we can make a constraint on it that comments can\u2019t exist without a user. <strong>NOTE: We will also discuss keys\u00a0soon.</strong>\n</li>\n<li>\n<strong>Domain integrity:</strong> Domain integrity is something to store the right value. It ensures that the integer data type has the integer value, not text. It can also check on the max. For example, char (20) should have a max of 20 characters.</li>\n</ol>\n<p>Terms in databases:</p>\n<p>Before getting deep dive into database design, let's have a look at the basic terms of the relational database. So that we can understand future concepts smoothly.</p>\n<ol>\n<li>\n<strong>Data:</strong> is something that you want to\u00a0store.</li>\n<li>\n<strong>Database:</strong> A database is something in which you store\u00a0data.</li>\n<li>\n<strong>Relational Database:</strong> A relational Database is one of the types of databases that allows storing data in table\u00a0form.</li>\n<li>\n<strong>DBMS:</strong> is a management system to handle the database.</li>\n<li>\n<strong>RDBMS:</strong> is a type of DBMS which allow handling the relational database</li>\n<li>\n<strong>NULL</strong>: When you do not provide value to attribute/ column.</li>\n<li>\n<strong>Anomalies:</strong> these are the bugs in the database or things that are not according to us what we are expecting. The incorrectness of\u00a0data.</li>\n<li>\n<strong>Entity:</strong> something about which you want to store\u00a0data.</li>\n<li>\n<strong>Attributes:</strong> are the columns like userID, phone No, or data you want to store of the\u00a0entity.</li>\n<li>\n<strong>Columns:</strong> Columns are the same as attributes. Just assume we change the\u00a0name.</li>\n<li>\n<strong>Field:</strong> Another name for columns and attributes.</li>\n<li>\n<strong>Relation:</strong> A relation is actually the relationship between the tables. Also, use it as the name of the\u00a0table.</li>\n<li>\n<strong>Table:</strong> Contain data in rows and\u00a0columns.</li>\n<li>\n<strong>File:</strong> Another name for table and relation.</li>\n<li>\n<strong>Tuple: </strong>attributes/values about the specific\u00a0entity.</li>\n<li>\n<strong>Rows:</strong> Another name for the\u00a0tuple.</li>\n<li>\n<strong>Records:</strong> Another name of Rows and\u00a0Tuple.</li>\n<li>\n<strong>Entry:</strong> Another name for the\u00a0tuple.</li>\n<li>\n<strong>Value:</strong> value that we put in a specific\u00a0column.</li>\n<li>\n<strong>DB Design:</strong> Process for removing anomalies and having data integrity.</li>\n<li>\n<strong>Schema:</strong> The structure of the database is known as\u00a0schema.</li>\n<li>\n<strong>Normalization:</strong> A process and bunch of steps for getting the best database design after removing problems in databases.</li>\n<li>\n<strong>Naming Convention:</strong> Consistency in naming things is necessary. It should be the same throughout the database\u00a0design.</li>\n<li>\n<strong>Keys:</strong> are used to make everything unique on the table. Connect one table with another like a user with a comment table using userID. We will discuss in detail about keys\u00a0soon.</li>\n</ol>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ec49906a282c\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*A2hIVUWlsVrjIQoaTG6Aig.jpeg\"></figure><p>Intro:</p>\n<p>We are going to do database design of relational databases where data is stored in tables. We are going to store data in such a way that we can handle it easily for reading, deleting, updating, and\u00a0putting.</p>\n<p>Why?</p>\n<p>In database design, we simply design the schemas which ensure that our database is efficient.</p>\n<p>What do you mean by database efficiency?</p>\n<p>Database Efficiency is about data integrity(Correctness of\u00a0data).</p>\n<p><strong>For Example:</strong> If 2 tables are connected (How connects we will discuss later), because of some reason connection gets lost between two tables then the change in one table will not be shown in the other table. That is what is called data incorrectness. We should prevent\u00a0it.</p>\n<p>Schemas:</p>\n<p>Schemas are just a thing of the schematic to build something that tells you the way in which data will be structured. In the database we have 3 levels of database\u00a0design:</p>\n<ol>\n<li>Conceptual Schema (Most\u00a0General)</li>\n<li>Logica Schema\u00a0(Inter)</li>\n<li>Physical Schema (Specific)</li>\n</ol>\n<p><strong>NOTE:</strong> Above types vary from person to person. This means people divide it according to their understanding but we are going with these types. Whenever you find something other than don't confuse\u00a0it.</p>\n<h3><strong>Conceptual Schema:</strong></h3>\n<p>At this, we decide the relationships between the tables. A relational database is all about the\u00a0tables.</p>\n<h3>Logical Schema:</h3>\n<p>is something where you decide the table's relationship types as they can be: one to many, many to one, or many to many (we will discuss relationships soon).</p>\n<h3>Physical Schema:</h3>\n<p>is something where you decide such type of things as which type of server you are going to use, How people will access data? Is it using the web form? we have to program it accordingly. And then when you physically implement that is a time to program the database, build the webform, install the server, test, view, data to be returned and the most important thing is <strong>security</strong>. From here we start thinking about security so that nobody can break down the database.</p>\n<h3><strong>Database Design:</strong></h3>\n<p>Database Design is all about dividing data among tables rather than having only one table. For example, we are building a database for the users and managing their sales. So in the database, we should make 2 tables, the first is for users and the second is for sale instead of having in one\u00a0table.</p>\n<p>Database Design ensures data integrity.</p>\n<h3>Data Integrity:</h3>\n<p>The correctness of data is called data integrity. The database doesn\u2019t want incorrect data, duplication, and broken relations between the\u00a0tables.</p>\n<p><strong>Three types of data integrity:</strong></p>\n<ol>\n<li>\n<strong>Entity Integrity: </strong>All about that only one table with one name. having some unique key which distinguishes between like users table having\u00a0id.</li>\n<li>\n<strong>Referential integrity:</strong> The relation between the tables. This relation is done by the foreign key. The foreign key constraint is understanding with an example that we have two 2 tables. \u201c<strong>Users\u201d</strong> and \u201c<strong>Comments\u201d</strong> So we can make a constraint on it that comments can\u2019t exist without a user. <strong>NOTE: We will also discuss keys\u00a0soon.</strong>\n</li>\n<li>\n<strong>Domain integrity:</strong> Domain integrity is something to store the right value. It ensures that the integer data type has the integer value, not text. It can also check on the max. For example, char (20) should have a max of 20 characters.</li>\n</ol>\n<p>Terms in databases:</p>\n<p>Before getting deep dive into database design, let's have a look at the basic terms of the relational database. So that we can understand future concepts smoothly.</p>\n<ol>\n<li>\n<strong>Data:</strong> is something that you want to\u00a0store.</li>\n<li>\n<strong>Database:</strong> A database is something in which you store\u00a0data.</li>\n<li>\n<strong>Relational Database:</strong> A relational Database is one of the types of databases that allows storing data in table\u00a0form.</li>\n<li>\n<strong>DBMS:</strong> is a management system to handle the database.</li>\n<li>\n<strong>RDBMS:</strong> is a type of DBMS which allow handling the relational database</li>\n<li>\n<strong>NULL</strong>: When you do not provide value to attribute/ column.</li>\n<li>\n<strong>Anomalies:</strong> these are the bugs in the database or things that are not according to us what we are expecting. The incorrectness of\u00a0data.</li>\n<li>\n<strong>Entity:</strong> something about which you want to store\u00a0data.</li>\n<li>\n<strong>Attributes:</strong> are the columns like userID, phone No, or data you want to store of the\u00a0entity.</li>\n<li>\n<strong>Columns:</strong> Columns are the same as attributes. Just assume we change the\u00a0name.</li>\n<li>\n<strong>Field:</strong> Another name for columns and attributes.</li>\n<li>\n<strong>Relation:</strong> A relation is actually the relationship between the tables. Also, use it as the name of the\u00a0table.</li>\n<li>\n<strong>Table:</strong> Contain data in rows and\u00a0columns.</li>\n<li>\n<strong>File:</strong> Another name for table and relation.</li>\n<li>\n<strong>Tuple: </strong>attributes/values about the specific\u00a0entity.</li>\n<li>\n<strong>Rows:</strong> Another name for the\u00a0tuple.</li>\n<li>\n<strong>Records:</strong> Another name of Rows and\u00a0Tuple.</li>\n<li>\n<strong>Entry:</strong> Another name for the\u00a0tuple.</li>\n<li>\n<strong>Value:</strong> value that we put in a specific\u00a0column.</li>\n<li>\n<strong>DB Design:</strong> Process for removing anomalies and having data integrity.</li>\n<li>\n<strong>Schema:</strong> The structure of the database is known as\u00a0schema.</li>\n<li>\n<strong>Normalization:</strong> A process and bunch of steps for getting the best database design after removing problems in databases.</li>\n<li>\n<strong>Naming Convention:</strong> Consistency in naming things is necessary. It should be the same throughout the database\u00a0design.</li>\n<li>\n<strong>Keys:</strong> are used to make everything unique on the table. Connect one table with another like a user with a comment table using userID. We will discuss in detail about keys\u00a0soon.</li>\n</ol>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ec49906a282c\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["terms","relational-databases","database-design","database"]},{"title":"Templates in CPP","pubDate":"2022-08-19 13:52:37","link":"https://medium.com/@talhariaz324/templates-in-cpp-9c0e2cc5d280?source=rss-4e14ced2bc7e------2","guid":"https://medium.com/p/9c0e2cc5d280","author":"Talha Riaz","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/626/1*G_b9D85zRvAprjzCupjL4Q.png\"></figure><h3><strong>What is a Template?</strong></h3>\n<p>A template is a structure that is already generated as a general and we can add our particular data of some specific data type to it for making a specific structure.</p>\n<h4><strong>Types:</strong></h4>\n<ol>\n<li>Function-based templates</li>\n<li>Class-base templates</li>\n</ol>\n<h4>For Example:</h4>\n<p>If we want ice frozen we can add water and freeze it, we can add milk if we want to produce the milk structure of ice. Similarly, we can add more things to produce the desired structure</p>\n<p>Similarly, In programming, we make algorithms whose logic remains the same but the data types of the given data change. Instead of writing the same function with different parameters, we can go with a template.</p>\n<p>The template is a generic function for all data\u00a0types.</p>\n<h4>Object file and Executable file:</h4>\n<p>CPP File do compilation and every CPP file will be generated object file. NOTE: Header files do not create an object\u00a0file</p>\n<p>Then Object file generates the executable code and the code is executed.</p>\n<p>The generic function template has no existence in memory. But the function which will be generated by it will place in the object\u00a0file.</p>\n<p>Once Compiler generates one int type of function, it will use the same int function for the future int\u00a0params.</p>\n<h4>How does a functional template\u00a0work?</h4>\n<p>When we call the function then first it goes to the template function and creates the desired function which will be call. The template function has no existence in the memory. Template function based on the data type of the params which is passed. This is called <strong>Implicit Argument Deduction.</strong></p>\n<p>And the function which is generated is called <strong>Templated Function</strong> which is a Specific CPP data type because it comes from a CPP\u00a0file.</p>\n<p><strong>For Example:</strong></p>\n<p>#include&lt;iostream&gt;</p>\n<p>using namespace std;</p>\n<p>template&lt;typename T&gt;</p>\n<p>void swap(T &amp; a, T &amp;\u00a0b){</p>\n<p>T temp =\u00a0a;</p>\n<p>a =\u00a0b;</p>\n<p>b =temp;</p>\n<p>}</p>\n<p>int main()\u00a0{</p>\n<p>double a = 333, b =\u00a012.5;</p>\n<p>cout&lt;&lt;a&lt;&lt;\u201d:\u201d&lt;&lt;b&lt;&lt;endl;</p>\n<p>swap(a,b);</p>\n<p>cout&lt;&lt;a&lt;&lt;\u201d:\u201d&lt;&lt;b&lt;&lt;endl;</p>\n<p>return 0;</p>\n<p>}</p>\n<p>Now Sometimes we need to use the <strong>explicit Argument Deduction</strong>.</p>\n<p>template&lt;typename T&gt;</p>\n<p>void display(T value){</p>\n<p>cout&lt;&lt;value;</p>\n<p>}</p>\n<p>In this case, we just call like <strong>display&lt;int&gt;(24.5);</strong> while 24.5 is double data-type but function will be generated or use already generated int function.</p>\n<p><strong>OUTPUT: 24</strong></p>\n<p>If we have different params mean one int another float\u00a0then:</p>\n<p>template&lt;typename T&gt;</p>\n<p>void swap(T a, T\u00a0b){</p>\n<p>}</p>\n<p>int main ()\u00a0{</p>\n<p><strong>Just Assuming a and\u00a0b</strong></p>\n<p>swap&lt;int&gt;(a,b) <strong>where a is int and b is\u00a0double</strong></p>\n<p>Here we can pass different params by using int and a little bit of syntax change of template.</p>\n<p>}</p>\n<p><strong>Can we also fix the above problem with the help of the below\u00a0syntax?</strong></p>\n<p>template&lt;typename T, typename\u00a0R&gt;</p>\n<p>void swap(T a, R\u00a0b){</p>\n<p>}</p>\n<p>int main ()\u00a0{</p>\n<p>swap(a,b) <strong>where a is int and b is\u00a0double</strong></p>\n<p>Here a is go for T and b is go for\u00a0R.</p>\n<p>}</p>\n<p>What if we want to pass two parameters to the template and use only one param in the function?</p>\n<p>template&lt;typename T, typename\u00a0R&gt;</p>\n<p>void swap(T a, T\u00a0b){</p>\n<p><strong>Here we need R which is not in the function parameters</strong></p>\n<p>}</p>\n<p>int main ()\u00a0{</p>\n<p><strong>Just Assuming a is int and b is\u00a0double</strong></p>\n<p>swap(a,b); <strong>Here error. because we are not using\u00a0R</strong></p>\n<p>swap&lt;int, double&gt;(a,b); <strong>Fixing an\u00a0error</strong></p>\n<p>}</p>\n<p><strong>What is T in\u00a0syntax?</strong></p>\n<p>T can be any name. Does not matter. But its scope is to its generic function. But it should be capital and\u00a0Single.</p>\n<p><strong>Why Class base template?</strong></p>\n<p>Sometimes you need a class in which you just want to change the data types. Instead of writing one class again and again for the different data-type, we should use the class templates.</p>\n<p><strong>NOTE:</strong> In the class base template we cannot use <strong>implicit Argument Deduction. </strong>We can only use <strong>explicit Argument Deduction.</strong></p>\n<p><strong>For Example:</strong></p>\n<ol>\n<li>In matrix class, you want to do manipulation and return. This can be for int and double etc. So we can use Class Template to handle\u00a0it.</li>\n<li>Union and Intersection of Persons or anything. Logic will remain the same but the data-type changes, So we can say or make a Class Template for\u00a0it.</li>\n</ol>\n<p><strong>To DO: Why we can\u2019t use implicit Argument Deduction?</strong> In case, you will not find any answer, you can ask\u00a0me.</p>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9c0e2cc5d280\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/626/1*G_b9D85zRvAprjzCupjL4Q.png\"></figure><h3><strong>What is a Template?</strong></h3>\n<p>A template is a structure that is already generated as a general and we can add our particular data of some specific data type to it for making a specific structure.</p>\n<h4><strong>Types:</strong></h4>\n<ol>\n<li>Function-based templates</li>\n<li>Class-base templates</li>\n</ol>\n<h4>For Example:</h4>\n<p>If we want ice frozen we can add water and freeze it, we can add milk if we want to produce the milk structure of ice. Similarly, we can add more things to produce the desired structure</p>\n<p>Similarly, In programming, we make algorithms whose logic remains the same but the data types of the given data change. Instead of writing the same function with different parameters, we can go with a template.</p>\n<p>The template is a generic function for all data\u00a0types.</p>\n<h4>Object file and Executable file:</h4>\n<p>CPP File do compilation and every CPP file will be generated object file. NOTE: Header files do not create an object\u00a0file</p>\n<p>Then Object file generates the executable code and the code is executed.</p>\n<p>The generic function template has no existence in memory. But the function which will be generated by it will place in the object\u00a0file.</p>\n<p>Once Compiler generates one int type of function, it will use the same int function for the future int\u00a0params.</p>\n<h4>How does a functional template\u00a0work?</h4>\n<p>When we call the function then first it goes to the template function and creates the desired function which will be call. The template function has no existence in the memory. Template function based on the data type of the params which is passed. This is called <strong>Implicit Argument Deduction.</strong></p>\n<p>And the function which is generated is called <strong>Templated Function</strong> which is a Specific CPP data type because it comes from a CPP\u00a0file.</p>\n<p><strong>For Example:</strong></p>\n<p>#include&lt;iostream&gt;</p>\n<p>using namespace std;</p>\n<p>template&lt;typename T&gt;</p>\n<p>void swap(T &amp; a, T &amp;\u00a0b){</p>\n<p>T temp =\u00a0a;</p>\n<p>a =\u00a0b;</p>\n<p>b =temp;</p>\n<p>}</p>\n<p>int main()\u00a0{</p>\n<p>double a = 333, b =\u00a012.5;</p>\n<p>cout&lt;&lt;a&lt;&lt;\u201d:\u201d&lt;&lt;b&lt;&lt;endl;</p>\n<p>swap(a,b);</p>\n<p>cout&lt;&lt;a&lt;&lt;\u201d:\u201d&lt;&lt;b&lt;&lt;endl;</p>\n<p>return 0;</p>\n<p>}</p>\n<p>Now Sometimes we need to use the <strong>explicit Argument Deduction</strong>.</p>\n<p>template&lt;typename T&gt;</p>\n<p>void display(T value){</p>\n<p>cout&lt;&lt;value;</p>\n<p>}</p>\n<p>In this case, we just call like <strong>display&lt;int&gt;(24.5);</strong> while 24.5 is double data-type but function will be generated or use already generated int function.</p>\n<p><strong>OUTPUT: 24</strong></p>\n<p>If we have different params mean one int another float\u00a0then:</p>\n<p>template&lt;typename T&gt;</p>\n<p>void swap(T a, T\u00a0b){</p>\n<p>}</p>\n<p>int main ()\u00a0{</p>\n<p><strong>Just Assuming a and\u00a0b</strong></p>\n<p>swap&lt;int&gt;(a,b) <strong>where a is int and b is\u00a0double</strong></p>\n<p>Here we can pass different params by using int and a little bit of syntax change of template.</p>\n<p>}</p>\n<p><strong>Can we also fix the above problem with the help of the below\u00a0syntax?</strong></p>\n<p>template&lt;typename T, typename\u00a0R&gt;</p>\n<p>void swap(T a, R\u00a0b){</p>\n<p>}</p>\n<p>int main ()\u00a0{</p>\n<p>swap(a,b) <strong>where a is int and b is\u00a0double</strong></p>\n<p>Here a is go for T and b is go for\u00a0R.</p>\n<p>}</p>\n<p>What if we want to pass two parameters to the template and use only one param in the function?</p>\n<p>template&lt;typename T, typename\u00a0R&gt;</p>\n<p>void swap(T a, T\u00a0b){</p>\n<p><strong>Here we need R which is not in the function parameters</strong></p>\n<p>}</p>\n<p>int main ()\u00a0{</p>\n<p><strong>Just Assuming a is int and b is\u00a0double</strong></p>\n<p>swap(a,b); <strong>Here error. because we are not using\u00a0R</strong></p>\n<p>swap&lt;int, double&gt;(a,b); <strong>Fixing an\u00a0error</strong></p>\n<p>}</p>\n<p><strong>What is T in\u00a0syntax?</strong></p>\n<p>T can be any name. Does not matter. But its scope is to its generic function. But it should be capital and\u00a0Single.</p>\n<p><strong>Why Class base template?</strong></p>\n<p>Sometimes you need a class in which you just want to change the data types. Instead of writing one class again and again for the different data-type, we should use the class templates.</p>\n<p><strong>NOTE:</strong> In the class base template we cannot use <strong>implicit Argument Deduction. </strong>We can only use <strong>explicit Argument Deduction.</strong></p>\n<p><strong>For Example:</strong></p>\n<ol>\n<li>In matrix class, you want to do manipulation and return. This can be for int and double etc. So we can use Class Template to handle\u00a0it.</li>\n<li>Union and Intersection of Persons or anything. Logic will remain the same but the data-type changes, So we can say or make a Class Template for\u00a0it.</li>\n</ol>\n<p><strong>To DO: Why we can\u2019t use implicit Argument Deduction?</strong> In case, you will not find any answer, you can ask\u00a0me.</p>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9c0e2cc5d280\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["programming","reusable","cpp"]},{"title":"Pointers learning volume 02","pubDate":"2022-08-12 15:23:10","link":"https://medium.com/@talhariaz324/pointers-learning-volume-02-d86314fe4298?source=rss-4e14ced2bc7e------2","guid":"https://medium.com/p/d86314fe4298","author":"Talha Riaz","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/598/1*wyXua1FX3wdFEX61bqi_XA.png\"></figure><h3>Play with constant pointer and constant variable:</h3>\n<p>int a = 10; <strong>a is non-constant pointer</strong>.</p>\n<p>const int * p = &amp;a; <strong>Is it feasible?</strong></p>\n<p>Yes. Because a is non-constant but when we make its pointer int to constant (not pointer const) then it means that this pointer cant change the value of\u00a0a.</p>\n<p>But,</p>\n<p>int * const p = &amp;a; <strong>Here a p pointer is a constant that we can\u2019t change but the value its points to is not constant so we can change\u00a0it.</strong></p>\n<p>NOW,</p>\n<p>const int b\u00a0=20;</p>\n<p>int * const p = &amp;b; <strong>Here is error.\u00a0Why?</strong></p>\n<p>Because b is constant but we are making pointer constant with the value it accesses is not constant. If the compiler allows passing from this\u00a0line:</p>\n<p>Then below lines will not show any error because the p pointer doesn\u2019t know that the b variable is constant it just\u2019s its own data type which allows him to run above the\u00a0line.</p>\n<p>int b\u00a0=20;</p>\n<p>const int * const p = &amp;b; Here p pointer can\u2019t change the value of the b variable as the p pointer data type is not allowed to change even b variable is non-constant.</p>\n<h3>Pointer shifting in\u00a0CPP:</h3>\n<p>int a = 16961; <strong>specific number for understanding</strong></p>\n<p>cout&lt;&lt;(int)*(char*)&amp;a; <strong>reads the address of int a then type-casting to char data type then again type-casting of that char to\u00a0int</strong></p>\n<p>Output: 65</p>\n<p>If want to access the 2nd byte of \u201ca\u201d then use: cout&lt;&lt;(int)*(char*)&amp;a+1;</p>\n<p>Output: 66</p>\n<p>Here we are accessing 1 byte just because of char, In the case of int then it will shift to 4\u00a0bytes.</p>\n<p>int * p = &amp;a; <strong>This will store the address of 4\u00a0byte</strong></p>\n<p>What if we want to just read 1 byte of\u00a0\u201ca\u201d?</p>\n<p>We can use: char * p = * (char*)&amp;a; <strong>Here use type-casting to char and then do dereference of\u00a0it</strong></p>\n<p>cout&lt;&lt;p[0]&lt;&lt;endl; <strong>This will show the first byte of\u00a0a.</strong></p>\n<p>cout&lt;&lt;p[1]&lt;&lt;endl; <strong>This will show the 2nd byte of\u00a0a.</strong></p>\n<p>Mean here we make int into the array of characters</p>\n<p>Output: A <strong>if we don\u2019t do dereference then address of 1st byte of\u00a0a</strong></p>\n<p>Output: B <strong>if we don\u2019t do dereference then address of 1st byte of\u00a0a</strong></p>\n<h3>Array passing to functions:</h3>\n<p>We can pass the array by two\u00a0methods:</p>\n<ol>\n<li><strong>Pass by\u00a0value</strong></li>\n<li><strong>Pass by reference</strong></li>\n</ol>\n<p>Pass by value consumes more time and\u00a0memory.</p>\n<p>So, the default method is to pass by reference.</p>\n<p>Now,</p>\n<p>Pass by reference also has two more\u00a0types:</p>\n<p><strong>1) By pointer As we are reading till\u00a0now</strong></p>\n<p><strong>2) By\u00a0Allias</strong></p>\n<p>You can understand it by just saying it is a \u201c<strong>synonym</strong>\u201d</p>\n<p>Alias:</p>\n<p>Alias ly the synonym of the same variable which points to the address of the same variable.</p>\n<p>e.g; int a =\u00a010;</p>\n<p>By pointer: int * p =\u00a0&amp;a;</p>\n<p>By Alias: int &amp; q =\u00a0a;</p>\n<p>Alias syntax is easy. Look it is saying that q is the <strong>synonym</strong> of \u201ca\u201d. It doesn\u2019t acquire memory (it actually acquires memory and somehow works like a pointer in the backend but for the ease of programmers, languages say that think it is a synonym or nickname).</p>\n<p>q = 20; <strong>This will change the value of\u00a0\u201ca\u201d.</strong></p>\n<p>An alias must be initialized at the time of declaration because it is constant.</p>\n<p>We can also make the alias of the\u00a0alias.</p>\n<p>int a =\u00a010;</p>\n<p>int &amp; q =\u00a0a;</p>\n<p>int &amp; r =\u00a0q;</p>\n<p>r = 30; <strong>This will change the value of a and q, r value gets itself\u00a0change</strong></p>\n<p><strong>Making an alias of\u00a0pointer:</strong></p>\n<p>int * p =\u00a0&amp;a;</p>\n<p>int * &amp; q = p; <strong>Alias of the pointer (the same syntax, just add the data type of\u00a0pointer)</strong></p>\n<p>NOTE: Allias is only the replacement of the const pointer. We have to use the pointers for dynamic addresses.</p>\n<h3>Why data\u00a0types?</h3>\n<p>Data Types always decide which type of operation we can do with any variable and specifically with the\u00a0pointer.</p>\n<p>The pointer does not know which value or which type of value is going to store in it. It just plays operation according to its own data\u00a0type.</p>\n<p>Character data types have some different scenarios as compared to other data\u00a0types.</p>\n<p>For Example:</p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;iostream&gt;</p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;cstring&gt;</p>\n<p>using namespace std;</p>\n<p>int main(){</p>\n<p>char s[100] = \u201cEducation\u201d;</p>\n<p>strcpy(s,\u201dHE\u201d); <strong>strcpy is a function that is used to overwrite the value the of string. So it overwrites the value of Ed with HE\u00a0now.</strong></p>\n<p>cout&lt;&lt;s[0]&lt;&lt;endl;</p>\n<p>return 0;</p>\n<p>}</p>\n<p>Secondly, it prints until it finds null in an array of characters and one more thing is that it does not print the address of a particular byte using \u201c&amp;\u201d. But direct print like cout&lt;&lt;&amp;s&lt;&lt;endl; <strong>print address of char\u00a0array</strong></p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;iostream&gt;</p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a> &lt;cstring&gt;</p>\n<p>using namespace std;</p>\n<p>int main(){</p>\n<p>char s[100] = \u201cEducation\u201d;</p>\n<p>strcpy(s,\u201dHE\u201d); <strong>strcpy is a function that is used to overwrite the value of the string. So it overwrites the value of Ed with HE\u00a0now.</strong></p>\n<p>cout&lt;&lt;&amp;s[0]&lt;&lt;endl; <strong>show HE and if remove index then with ampersand show address. if add index 3 with ampersand then it will also print the whole array from index 3 to NULL. Simple \u201cs\u201d with ampersand show\u00a0address</strong></p>\n<p>return 0;</p>\n<h3>}</h3>\n<h3>Let\u2019s test ourselves for data\u00a0type:</h3>\n<p>int a =\u00a090;</p>\n<p>int* p1 = &amp;a; <strong>&amp;a data type is int* and so it matched with the data type of identifier</strong></p>\n<p>int* const p2 = &amp;a; <strong>&amp;a data type is int* and here identifier type is int*\u00a0const</strong></p>\n<p>The above line is valid even though the types do not match. But type matches, const is saying that I will not change the received pointer. And received pointer is saying that you can change me or not, it\u2019s up to\u00a0you.</p>\n<p>const int** q = &amp;p1; <strong>Type of &amp;p1 is int** and here identifier type is saying that non-constant pointer and value will be treated as constant. So, it\u2019s possible.</strong></p>\n<p>const int** q = &amp;p2; <strong>Type of &amp;p2 is int* const * and here identifier type is saying that non-constant pointer which is bad here because it can change the value and value data type is saying I cannot\u00a0change.</strong></p>\n<p>*q = p2; <strong>Type of p2 int* const while identifier data type can be evaluated by just skipping 1 star in the above line. so data type becomes const int*. Same problem, Value data type saying that pointer is constant and identifier saying that I will change which is not\u00a0good.</strong></p>\n<p><strong>Dangling pointer:</strong> A dangling pointer is a pointer to memory that is no longer allocated.</p>\n<h3>Dynamic memory and\u00a0alias:</h3>\n<p>As you know alias behaves like a constant pointer. When you make an alias of dynamic memory then it points to complete memory which is made by a new keyword on the heap by pointing address of starting\u00a0byte.</p>\n<p>When we deallocate it, then the alias will point to garbage value but not get changed. Because alias will always point to the same memory once it allocates to it even if that memory is deleted. That\u2019s why we don\u2019t use an alias with dynamic\u00a0memory.</p>\n<p>int* p = new int; <strong>new int data type is int* because new gives the address of starting\u00a0byte</strong></p>\n<p>Making alias:</p>\n<p>int &amp; p = *(new int); <strong>dereference on right side give or return with heap memory (as discussed below) and now we can give an alias to\u00a0it.</strong></p>\n<p>Now here we make an alias of new int heap\u00a0memory.</p>\n<p><strong>MAIN CONCEPT:</strong></p>\n<p>1) *p1= go and write the value at the p1\u00a0address</p>\n<p>2) =*p1 go and read the bytes according to data type and come\u00a0back</p>\n<h3>Deallocate memory:</h3>\n<p>delete &amp;p;</p>\n<p>But the alias is still there and has the garbage value. So after delete, the alias becomes dangling which means it can cause runtime error because now p points to illegal\u00a0memory.</p>\n<h3>Let\u2019s clarify one concept\u00a0more:</h3>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;iostream&gt;</p>\n<p>using namespace std;</p>\n<p>int main\u00a0()</p>\n<p>{</p>\n<p>int* p = new int; Make 4 bytes in\u00a0heap</p>\n<p>delete p; Now memory is deleted, not\u00a0variable</p>\n<p>int* q = new\u00a0int;</p>\n<p>*p = 100; <strong>This is allowed because we delete heap memory above and again make heap memory with a different name. But we can use the previous name to assign value to the heap because we need memory doesn\u2019t matter when initialized.</strong></p>\n<p>}</p>\n<p><strong>Null pointer:</strong> This has nullPtr and dereferencing this is called null pointer assignment error (Runtime error just say it is null where should I\u00a0go).</p>\n<p>Pointer in which no address of reserved memory but some non-zero value, dereferencing this type of is known as dereferencing of the dangling pointer. This can cause to disturb other memory (Illegal memory access cause runtime\u00a0error).</p>\n<p><strong>Memory leak:</strong> You reserved some memory but this memory is not pointing by anything in your program then this memory remains reserved in memory and has some garbage value throughout the program so it is called a memory\u00a0leak.</p>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d86314fe4298\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/598/1*wyXua1FX3wdFEX61bqi_XA.png\"></figure><h3>Play with constant pointer and constant variable:</h3>\n<p>int a = 10; <strong>a is non-constant pointer</strong>.</p>\n<p>const int * p = &amp;a; <strong>Is it feasible?</strong></p>\n<p>Yes. Because a is non-constant but when we make its pointer int to constant (not pointer const) then it means that this pointer cant change the value of\u00a0a.</p>\n<p>But,</p>\n<p>int * const p = &amp;a; <strong>Here a p pointer is a constant that we can\u2019t change but the value its points to is not constant so we can change\u00a0it.</strong></p>\n<p>NOW,</p>\n<p>const int b\u00a0=20;</p>\n<p>int * const p = &amp;b; <strong>Here is error.\u00a0Why?</strong></p>\n<p>Because b is constant but we are making pointer constant with the value it accesses is not constant. If the compiler allows passing from this\u00a0line:</p>\n<p>Then below lines will not show any error because the p pointer doesn\u2019t know that the b variable is constant it just\u2019s its own data type which allows him to run above the\u00a0line.</p>\n<p>int b\u00a0=20;</p>\n<p>const int * const p = &amp;b; Here p pointer can\u2019t change the value of the b variable as the p pointer data type is not allowed to change even b variable is non-constant.</p>\n<h3>Pointer shifting in\u00a0CPP:</h3>\n<p>int a = 16961; <strong>specific number for understanding</strong></p>\n<p>cout&lt;&lt;(int)*(char*)&amp;a; <strong>reads the address of int a then type-casting to char data type then again type-casting of that char to\u00a0int</strong></p>\n<p>Output: 65</p>\n<p>If want to access the 2nd byte of \u201ca\u201d then use: cout&lt;&lt;(int)*(char*)&amp;a+1;</p>\n<p>Output: 66</p>\n<p>Here we are accessing 1 byte just because of char, In the case of int then it will shift to 4\u00a0bytes.</p>\n<p>int * p = &amp;a; <strong>This will store the address of 4\u00a0byte</strong></p>\n<p>What if we want to just read 1 byte of\u00a0\u201ca\u201d?</p>\n<p>We can use: char * p = * (char*)&amp;a; <strong>Here use type-casting to char and then do dereference of\u00a0it</strong></p>\n<p>cout&lt;&lt;p[0]&lt;&lt;endl; <strong>This will show the first byte of\u00a0a.</strong></p>\n<p>cout&lt;&lt;p[1]&lt;&lt;endl; <strong>This will show the 2nd byte of\u00a0a.</strong></p>\n<p>Mean here we make int into the array of characters</p>\n<p>Output: A <strong>if we don\u2019t do dereference then address of 1st byte of\u00a0a</strong></p>\n<p>Output: B <strong>if we don\u2019t do dereference then address of 1st byte of\u00a0a</strong></p>\n<h3>Array passing to functions:</h3>\n<p>We can pass the array by two\u00a0methods:</p>\n<ol>\n<li><strong>Pass by\u00a0value</strong></li>\n<li><strong>Pass by reference</strong></li>\n</ol>\n<p>Pass by value consumes more time and\u00a0memory.</p>\n<p>So, the default method is to pass by reference.</p>\n<p>Now,</p>\n<p>Pass by reference also has two more\u00a0types:</p>\n<p><strong>1) By pointer As we are reading till\u00a0now</strong></p>\n<p><strong>2) By\u00a0Allias</strong></p>\n<p>You can understand it by just saying it is a \u201c<strong>synonym</strong>\u201d</p>\n<p>Alias:</p>\n<p>Alias ly the synonym of the same variable which points to the address of the same variable.</p>\n<p>e.g; int a =\u00a010;</p>\n<p>By pointer: int * p =\u00a0&amp;a;</p>\n<p>By Alias: int &amp; q =\u00a0a;</p>\n<p>Alias syntax is easy. Look it is saying that q is the <strong>synonym</strong> of \u201ca\u201d. It doesn\u2019t acquire memory (it actually acquires memory and somehow works like a pointer in the backend but for the ease of programmers, languages say that think it is a synonym or nickname).</p>\n<p>q = 20; <strong>This will change the value of\u00a0\u201ca\u201d.</strong></p>\n<p>An alias must be initialized at the time of declaration because it is constant.</p>\n<p>We can also make the alias of the\u00a0alias.</p>\n<p>int a =\u00a010;</p>\n<p>int &amp; q =\u00a0a;</p>\n<p>int &amp; r =\u00a0q;</p>\n<p>r = 30; <strong>This will change the value of a and q, r value gets itself\u00a0change</strong></p>\n<p><strong>Making an alias of\u00a0pointer:</strong></p>\n<p>int * p =\u00a0&amp;a;</p>\n<p>int * &amp; q = p; <strong>Alias of the pointer (the same syntax, just add the data type of\u00a0pointer)</strong></p>\n<p>NOTE: Allias is only the replacement of the const pointer. We have to use the pointers for dynamic addresses.</p>\n<h3>Why data\u00a0types?</h3>\n<p>Data Types always decide which type of operation we can do with any variable and specifically with the\u00a0pointer.</p>\n<p>The pointer does not know which value or which type of value is going to store in it. It just plays operation according to its own data\u00a0type.</p>\n<p>Character data types have some different scenarios as compared to other data\u00a0types.</p>\n<p>For Example:</p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;iostream&gt;</p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;cstring&gt;</p>\n<p>using namespace std;</p>\n<p>int main(){</p>\n<p>char s[100] = \u201cEducation\u201d;</p>\n<p>strcpy(s,\u201dHE\u201d); <strong>strcpy is a function that is used to overwrite the value the of string. So it overwrites the value of Ed with HE\u00a0now.</strong></p>\n<p>cout&lt;&lt;s[0]&lt;&lt;endl;</p>\n<p>return 0;</p>\n<p>}</p>\n<p>Secondly, it prints until it finds null in an array of characters and one more thing is that it does not print the address of a particular byte using \u201c&amp;\u201d. But direct print like cout&lt;&lt;&amp;s&lt;&lt;endl; <strong>print address of char\u00a0array</strong></p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;iostream&gt;</p>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a> &lt;cstring&gt;</p>\n<p>using namespace std;</p>\n<p>int main(){</p>\n<p>char s[100] = \u201cEducation\u201d;</p>\n<p>strcpy(s,\u201dHE\u201d); <strong>strcpy is a function that is used to overwrite the value of the string. So it overwrites the value of Ed with HE\u00a0now.</strong></p>\n<p>cout&lt;&lt;&amp;s[0]&lt;&lt;endl; <strong>show HE and if remove index then with ampersand show address. if add index 3 with ampersand then it will also print the whole array from index 3 to NULL. Simple \u201cs\u201d with ampersand show\u00a0address</strong></p>\n<p>return 0;</p>\n<h3>}</h3>\n<h3>Let\u2019s test ourselves for data\u00a0type:</h3>\n<p>int a =\u00a090;</p>\n<p>int* p1 = &amp;a; <strong>&amp;a data type is int* and so it matched with the data type of identifier</strong></p>\n<p>int* const p2 = &amp;a; <strong>&amp;a data type is int* and here identifier type is int*\u00a0const</strong></p>\n<p>The above line is valid even though the types do not match. But type matches, const is saying that I will not change the received pointer. And received pointer is saying that you can change me or not, it\u2019s up to\u00a0you.</p>\n<p>const int** q = &amp;p1; <strong>Type of &amp;p1 is int** and here identifier type is saying that non-constant pointer and value will be treated as constant. So, it\u2019s possible.</strong></p>\n<p>const int** q = &amp;p2; <strong>Type of &amp;p2 is int* const * and here identifier type is saying that non-constant pointer which is bad here because it can change the value and value data type is saying I cannot\u00a0change.</strong></p>\n<p>*q = p2; <strong>Type of p2 int* const while identifier data type can be evaluated by just skipping 1 star in the above line. so data type becomes const int*. Same problem, Value data type saying that pointer is constant and identifier saying that I will change which is not\u00a0good.</strong></p>\n<p><strong>Dangling pointer:</strong> A dangling pointer is a pointer to memory that is no longer allocated.</p>\n<h3>Dynamic memory and\u00a0alias:</h3>\n<p>As you know alias behaves like a constant pointer. When you make an alias of dynamic memory then it points to complete memory which is made by a new keyword on the heap by pointing address of starting\u00a0byte.</p>\n<p>When we deallocate it, then the alias will point to garbage value but not get changed. Because alias will always point to the same memory once it allocates to it even if that memory is deleted. That\u2019s why we don\u2019t use an alias with dynamic\u00a0memory.</p>\n<p>int* p = new int; <strong>new int data type is int* because new gives the address of starting\u00a0byte</strong></p>\n<p>Making alias:</p>\n<p>int &amp; p = *(new int); <strong>dereference on right side give or return with heap memory (as discussed below) and now we can give an alias to\u00a0it.</strong></p>\n<p>Now here we make an alias of new int heap\u00a0memory.</p>\n<p><strong>MAIN CONCEPT:</strong></p>\n<p>1) *p1= go and write the value at the p1\u00a0address</p>\n<p>2) =*p1 go and read the bytes according to data type and come\u00a0back</p>\n<h3>Deallocate memory:</h3>\n<p>delete &amp;p;</p>\n<p>But the alias is still there and has the garbage value. So after delete, the alias becomes dangling which means it can cause runtime error because now p points to illegal\u00a0memory.</p>\n<h3>Let\u2019s clarify one concept\u00a0more:</h3>\n<p><a href=\"https://www.linkedin.com/feed/hashtag/include\">#include</a>&lt;iostream&gt;</p>\n<p>using namespace std;</p>\n<p>int main\u00a0()</p>\n<p>{</p>\n<p>int* p = new int; Make 4 bytes in\u00a0heap</p>\n<p>delete p; Now memory is deleted, not\u00a0variable</p>\n<p>int* q = new\u00a0int;</p>\n<p>*p = 100; <strong>This is allowed because we delete heap memory above and again make heap memory with a different name. But we can use the previous name to assign value to the heap because we need memory doesn\u2019t matter when initialized.</strong></p>\n<p>}</p>\n<p><strong>Null pointer:</strong> This has nullPtr and dereferencing this is called null pointer assignment error (Runtime error just say it is null where should I\u00a0go).</p>\n<p>Pointer in which no address of reserved memory but some non-zero value, dereferencing this type of is known as dereferencing of the dangling pointer. This can cause to disturb other memory (Illegal memory access cause runtime\u00a0error).</p>\n<p><strong>Memory leak:</strong> You reserved some memory but this memory is not pointing by anything in your program then this memory remains reserved in memory and has some garbage value throughout the program so it is called a memory\u00a0leak.</p>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d86314fe4298\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]},{"title":"Difficult to understand pointers? Not Anymore","pubDate":"2022-08-05 16:17:16","link":"https://medium.com/@talhariaz324/difficult-to-understand-pointers-not-anymore-1138f56118db?source=rss-4e14ced2bc7e------2","guid":"https://medium.com/p/1138f56118db","author":"Talha Riaz","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*klxvvvK8dDWQQ49jSZ_Jhw.jpeg\"></figure><p><strong>REASON</strong>: A big reason behind the understanding of pointers is a lack of knowledge about data types in the language. So we are going to clear our basic understanding regarding data types and then move to pointers, which will become easy for us to understand.</p>\n<p><strong>NOTE:</strong> We are going to learn everything according to the C++ language. Other languages are also very similar to\u00a0it.</p>\n<p><strong>Data Types:</strong></p>\n<p><strong>Default data types in code\u00a0are:</strong></p>\n<ol>\n<li>integrals like 10, 15, 40 (treated as\u00a0int)</li>\n<li>floats like 10.3, 3.2 (treated as\u00a0double)</li>\n</ol>\n<p>But in memory, the type will remain the same as you mention for the identifier.</p>\n<p>For Example: double b =\u00a090;</p>\n<p>What do you think about the data type of b in code? Are you going to say double? If yes, then absolutely not. The type of b in code is int, and the type of b in memory is double. The reason is that there are only data types in\u00a0code:</p>\n<ul>\n<li>int</li>\n<li>double</li>\n</ul>\n<p>If the literal is of data type int and the identifier of data type double then the data type of literal remains the int in the code, but only the data type in memory of the identifier would be\u00a0double.</p>\n<p>Let\u2019s discuss a few more examples:</p>\n<ol>\n<li>int a = 13; <strong>a is int in code and a is also int in\u00a0memory</strong>\n</li>\n<li>int a = 10.5; <strong>a is double in code and a is int in\u00a0memory</strong>\n</li>\n<li>float b = 65.5; <strong>literal is double in code and this b in memory is\u00a0float</strong>\n</li>\n</ol>\n<p><strong>Why a data type is not float in\u00a0code?</strong></p>\n<p>Because in code data type is only of two types as discussed above.</p>\n<p>Now it\u2019s time to understand the pointers.</p>\n<p><strong>Understanding data types of Pointers:</strong></p>\n<p>int a =\u00a010;</p>\n<p>int * p =\u00a0&amp;a;</p>\n<ol>\n<li>The data type of &amp;a is int * because we are storing the address of a which has the type of int. It is read as a pointer to int (from left to write and * read as a pointer).</li>\n<li>int *p read as p is a pointer to int non-const.</li>\n</ol>\n<p>int** q =\u00a0&amp;p;</p>\n<ol>\n<li>The data type of &amp;p is int ** because already have an int* and 1 more have &amp; (address) so use 1 more\u00a0*.</li>\n<li>int ** q read as q is pointer to pointer to int non-const.</li>\n</ol>\n<p>&amp;q; <strong>What will be the data\u00a0type?</strong></p>\n<p>Similarly for\u00a0const</p>\n<p>const int b =\u00a090;</p>\n<p>const int * p =\u00a0&amp;b;</p>\n<ol>\n<li>The data type of &amp;b is const int\u00a0*.</li>\n<li>const int* p read as p is a pointer to int\u00a0const</li>\n</ol>\n<p>const int ** q =\u00a0&amp;p;</p>\n<ol>\n<li>The data type of &amp;p is const int ** because already have an int* and 1 more have &amp; (address) so 1 more\u00a0*.</li>\n<li>const int** q read as q is a pointer to pointer int\u00a0const</li>\n</ol>\n<p>&amp;q; <strong>What will be the data\u00a0type?</strong></p>\n<p>In volume 02, we will learn more about pointers.</p>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1138f56118db\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*klxvvvK8dDWQQ49jSZ_Jhw.jpeg\"></figure><p><strong>REASON</strong>: A big reason behind the understanding of pointers is a lack of knowledge about data types in the language. So we are going to clear our basic understanding regarding data types and then move to pointers, which will become easy for us to understand.</p>\n<p><strong>NOTE:</strong> We are going to learn everything according to the C++ language. Other languages are also very similar to\u00a0it.</p>\n<p><strong>Data Types:</strong></p>\n<p><strong>Default data types in code\u00a0are:</strong></p>\n<ol>\n<li>integrals like 10, 15, 40 (treated as\u00a0int)</li>\n<li>floats like 10.3, 3.2 (treated as\u00a0double)</li>\n</ol>\n<p>But in memory, the type will remain the same as you mention for the identifier.</p>\n<p>For Example: double b =\u00a090;</p>\n<p>What do you think about the data type of b in code? Are you going to say double? If yes, then absolutely not. The type of b in code is int, and the type of b in memory is double. The reason is that there are only data types in\u00a0code:</p>\n<ul>\n<li>int</li>\n<li>double</li>\n</ul>\n<p>If the literal is of data type int and the identifier of data type double then the data type of literal remains the int in the code, but only the data type in memory of the identifier would be\u00a0double.</p>\n<p>Let\u2019s discuss a few more examples:</p>\n<ol>\n<li>int a = 13; <strong>a is int in code and a is also int in\u00a0memory</strong>\n</li>\n<li>int a = 10.5; <strong>a is double in code and a is int in\u00a0memory</strong>\n</li>\n<li>float b = 65.5; <strong>literal is double in code and this b in memory is\u00a0float</strong>\n</li>\n</ol>\n<p><strong>Why a data type is not float in\u00a0code?</strong></p>\n<p>Because in code data type is only of two types as discussed above.</p>\n<p>Now it\u2019s time to understand the pointers.</p>\n<p><strong>Understanding data types of Pointers:</strong></p>\n<p>int a =\u00a010;</p>\n<p>int * p =\u00a0&amp;a;</p>\n<ol>\n<li>The data type of &amp;a is int * because we are storing the address of a which has the type of int. It is read as a pointer to int (from left to write and * read as a pointer).</li>\n<li>int *p read as p is a pointer to int non-const.</li>\n</ol>\n<p>int** q =\u00a0&amp;p;</p>\n<ol>\n<li>The data type of &amp;p is int ** because already have an int* and 1 more have &amp; (address) so use 1 more\u00a0*.</li>\n<li>int ** q read as q is pointer to pointer to int non-const.</li>\n</ol>\n<p>&amp;q; <strong>What will be the data\u00a0type?</strong></p>\n<p>Similarly for\u00a0const</p>\n<p>const int b =\u00a090;</p>\n<p>const int * p =\u00a0&amp;b;</p>\n<ol>\n<li>The data type of &amp;b is const int\u00a0*.</li>\n<li>const int* p read as p is a pointer to int\u00a0const</li>\n</ol>\n<p>const int ** q =\u00a0&amp;p;</p>\n<ol>\n<li>The data type of &amp;p is const int ** because already have an int* and 1 more have &amp; (address) so 1 more\u00a0*.</li>\n<li>const int** q read as q is a pointer to pointer int\u00a0const</li>\n</ol>\n<p>&amp;q; <strong>What will be the data\u00a0type?</strong></p>\n<p>In volume 02, we will learn more about pointers.</p>\n<p><strong>Correct me if you find something wrong. Thank\u00a0You!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1138f56118db\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]}]}